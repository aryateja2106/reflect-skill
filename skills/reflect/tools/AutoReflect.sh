#!/bin/bash
# AutoReflect.sh - Lightweight session-end scanner for Stop hook
#
# Usage:
#   ./AutoReflect.sh [session_context]
#
# Purpose:
#   - Scans session for HIGH priority corrections only
#   - Queues findings to reflect-queue.md
#   - Silent operation - no user interaction
#
# Exit codes:
#   0 - Success (corrections queued or none found)
#   1 - Error

set -euo pipefail

PAI_DIR="${PAI_DIR:-$HOME/.claude}"
QUEUE_FILE="${PAI_DIR}/Scratchpad/reflect-queue.md"
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
SESSION_ID="${1:-$(date +%s)}"

# HIGH priority patterns to detect
HIGH_PATTERNS=(
  "don't"
  "dont"
  "do not"
  "never"
  "wrong"
  "incorrect"
  "stop doing"
  "stop using"
  "instead use"
  "use .* instead"
)

# Ensure scratchpad directory exists
mkdir -p "$(dirname "$QUEUE_FILE")"

# Initialize queue file if it doesn't exist
if [[ ! -f "$QUEUE_FILE" ]]; then
  cat > "$QUEUE_FILE" << 'EOF'
# Reflect Queue
<!-- Auto-generated by /reflect auto workflow -->

EOF
fi

# Function to queue a correction
queue_correction() {
  local quote="$1"
  local suggested="$2"

  # Truncate if too long
  quote="${quote:0:200}"
  suggested="${suggested:0:100}"

  # Check if this session's header already exists
  if ! grep -q "## Pending from $TIMESTAMP" "$QUEUE_FILE" 2>/dev/null; then
    echo "" >> "$QUEUE_FILE"
    echo "## Pending from $TIMESTAMP" >> "$QUEUE_FILE"
    echo "" >> "$QUEUE_FILE"
  fi

  # Append the correction
  cat >> "$QUEUE_FILE" << EOF
- **"$quote"**
  - Suggested: $suggested
  - Session: $SESSION_ID

EOF
}

# Main execution
# In a real implementation, this would receive session context
# For now, this is a placeholder that can be called with explicit corrections

# Check if input was provided via stdin or argument
if [[ -t 0 ]] && [[ -z "${2:-}" ]]; then
  # No input provided - silent exit (nothing to queue)
  exit 0
fi

# Process input if provided
if [[ -n "${2:-}" ]]; then
  # Called with explicit correction: ./AutoReflect.sh "session_id" "correction text"
  CORRECTION="$2"
  SUGGESTED="${3:-Review and create appropriate rule}"
  queue_correction "$CORRECTION" "$SUGGESTED"
  exit 0
fi

# Read from stdin if piped
while IFS= read -r line; do
  # Skip empty lines
  [[ -z "$line" ]] && continue

  # Check for HIGH priority patterns
  for pattern in "${HIGH_PATTERNS[@]}"; do
    if echo "$line" | grep -iqE "$pattern"; then
      # Extract a suggested rule (simple heuristic)
      suggested=$(echo "$line" | sed -E 's/^.*?(don.?t|never|wrong|stop|instead)//i' | sed 's/^[[:space:]]*//' | head -c 100)
      [[ -z "$suggested" ]] && suggested="Review and create appropriate rule"
      queue_correction "$line" "$suggested"
      break
    fi
  done
done

echo "Corrections queued to: $QUEUE_FILE" >&2
exit 0
